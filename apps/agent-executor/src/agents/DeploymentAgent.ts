/**
 * Deployment Agent
 * Creates Docker files, CI/CD configs, deployment scripts
 */

import { saveToFile } from '../utils/fileWriter.js';
import type { TaskContract, AgentOutput } from './index.js';
import path from 'path';

export class DeploymentAgent {
  static async execute(contract: TaskContract): Promise<AgentOutput> {
    console.log('ðŸš€ Deployment Agent: Creating deployment files...');

    const projectDir = path.join(
      process.env.OUTPUT_DIR!,
      `project-${contract.project_id}`
    );

    const filesGenerated: string[] = [];

    // Generate Dockerfile for backend
    const backendDockerfile = this.generateBackendDockerfile();
    filesGenerated.push(
      await saveToFile(projectDir, 'backend/Dockerfile', backendDockerfile)
    );

    // Generate Dockerfile for frontend
    const frontendDockerfile = this.generateFrontendDockerfile();
    filesGenerated.push(
      await saveToFile(projectDir, 'frontend/Dockerfile', frontendDockerfile)
    );

    // Generate docker-compose.yml
    const dockerCompose = this.generateDockerCompose();
    filesGenerated.push(
      await saveToFile(projectDir, 'docker-compose.yml', dockerCompose)
    );

    // Generate GitHub Actions CI/CD
    const githubActions = this.generateGitHubActions();
    filesGenerated.push(
      await saveToFile(projectDir, '.github/workflows/deploy.yml', githubActions)
    );

    // Generate deployment README
    const deployReadme = this.generateDeployReadme();
    filesGenerated.push(
      await saveToFile(projectDir, 'DEPLOYMENT.md', deployReadme)
    );

    return {
      success: true,
      filesGenerated,
      outputPath: projectDir,
      summary: 'Deployment configs created: Docker, CI/CD, scripts',
      metadata: { deploymentType: 'Docker + GitHub Actions' },
    };
  }

  private static generateBackendDockerfile(): string {
    return `FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

EXPOSE 4000

CMD ["npm", "start"]
`;
  }

  private static generateFrontendDockerfile(): string {
    return `FROM node:20-alpine AS builder

WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM node:20-alpine

WORKDIR /app

COPY --from=builder /app/.next ./.next
COPY --from=builder /app/public ./public
COPY --from=builder /app/package*.json ./
RUN npm ci --only=production

EXPOSE 3000

CMD ["npm", "start"]
`;
  }

  private static generateDockerCompose(): string {
    return `version: '3.8'

services:
  backend:
    build: ./backend
    ports:
      - "4000:4000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/app
      - NODE_ENV=production
    depends_on:
      - db

  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=http://backend:4000
    depends_on:
      - backend

  db:
    image: postgres:16-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=app
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
`;
  }

  private static generateGitHubActions(): string {
    return `name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Build Docker images
        run: |
          docker build -t myapp-backend ./backend
          docker build -t myapp-frontend ./frontend
      
      - name: Deploy to AWS
        run: |
          # Add your deployment commands here
          echo "Deploying to production..."
`;
  }

  private static generateDeployReadme(): string {
    return `# Deployment Guide

## Local Development

\`\`\`bash
docker-compose up
\`\`\`

Access:
- Frontend: http://localhost:3000
- Backend: http://localhost:4000

## Production Deployment

### Option 1: Docker
\`\`\`bash
docker-compose -f docker-compose.prod.yml up -d
\`\`\`

### Option 2: AWS ECS
See .github/workflows/deploy.yml for CI/CD

---
*Generated by Devagent Deployment Agent*
`;
  }
}
