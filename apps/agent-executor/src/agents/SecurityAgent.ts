/**
 * Security Agent
 * Scans generated code for vulnerabilities
 */

import { callAIWithJSON } from '../llm/index.js';
import { saveToFile } from '../utils/fileWriter.js';
import type { TaskContract, AgentOutput } from './index.js';
import path from 'path';
import fs from 'fs-extra';

export class SecurityAgent {
  static async execute(contract: TaskContract): Promise<AgentOutput> {
    console.log('ðŸ”’ Security Agent: Scanning code for vulnerabilities...');

    const projectDir = path.join(
      process.env.OUTPUT_DIR!,
      `project-${contract.project_id}`
    );

    const filesGenerated: string[] = [];

    // Read generated backend code
    const backendDir = path.join(projectDir, 'backend/src');
    const codeFiles = await this.readCodeFiles(backendDir);

    // Analyze each file with GPT-4
    const vulnerabilities = [];
    for (const [file, code] of Object.entries(codeFiles).slice(0, 5)) {
      const analysis = await this.analyzeFile(file, code);
      vulnerabilities.push(...analysis.issues);
    }

    // Generate security report
    const report = this.generateSecurityReport(vulnerabilities);
    const reportFile = await saveToFile(
      projectDir,
      'security/SECURITY_REPORT.md',
      report
    );
    filesGenerated.push(reportFile);

    return {
      success: true,
      filesGenerated,
      outputPath: projectDir,
      summary: `Security scan: ${vulnerabilities.length} issues found`,
      metadata: { 
        vulnerabilities,
        critical: vulnerabilities.filter((v: any) => v.severity === 'critical').length,
      },
    };
  }

  private static async readCodeFiles(dir: string): Promise<Record<string, string>> {
    const files: Record<string, string> = {};
    
    if (!await fs.pathExists(dir)) {
      return files;
    }

    const entries = await fs.readdir(dir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isFile() && entry.name.endsWith('.ts')) {
        files[entry.name] = await fs.readFile(fullPath, 'utf-8');
      }
    }

    return files;
  }

  private static async analyzeFile(filename: string, code: string): Promise<any> {
    const prompt = `Analyze this TypeScript code for security vulnerabilities:

File: ${filename}
\`\`\`typescript
${code.slice(0, 3000)} // Truncated
\`\`\`

Check for:
- SQL injection risks
- XSS vulnerabilities
- Authentication flaws
- Sensitive data exposure
- Input validation issues

Return JSON:
{
  "issues": [
    {
      "severity": "critical" | "high" | "medium" | "low",
      "type": "SQL Injection",
      "description": "...",
      "line": 42,
      "recommendation": "..."
    }
  ]
}`;

    try {
      return await callAIWithJSON([
        { role: 'system', content: 'You are a security expert.' },
        { role: 'user', content: prompt },
      ]);
    } catch {
      return { issues: [] };
    }
  }

  private static generateSecurityReport(vulnerabilities: any[]): string {
    const critical = vulnerabilities.filter(v => v.severity === 'critical');
    const high = vulnerabilities.filter(v => v.severity === 'high');
    const medium = vulnerabilities.filter(v => v.severity === 'medium');

    return `# Security Scan Report

## Summary
- **Critical:** ${critical.length}
- **High:** ${high.length}
- **Medium:** ${medium.length}
- **Total:** ${vulnerabilities.length}

## Issues

${vulnerabilities.map((v, i) => `
### ${i + 1}. ${v.type} (${v.severity.toUpperCase()})
**File:** ${v.file || 'Unknown'}
**Line:** ${v.line || 'N/A'}
**Description:** ${v.description}
**Recommendation:** ${v.recommendation}
`).join('\n')}

---
*Generated by Devagent Security Agent*
`;
  }
}
